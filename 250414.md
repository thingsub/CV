# 250414
## Image Histogram
### Mat 클래스
- 이미지를 행렬 형태로 저장
- ``` C++
  Mat srcImage = imread("lena.jpg"); // srcImage는 Mat 객체이고, 이미지 파일을 불러와서 메모리에 저장함.
  ```
#### Q. cv::Mat 활용 이유?
- Mat은 단순히 이미지만 저장하는 클래스가 아님. 행렬 형태의 데이터라면 이미지든 필터 커널이든 히스토그램이든 모두 표현 가능
- calcHist() 같은 함수들이 히스토그램 출력을 Mat으로 반환

### 이미지 채널 분리(split)
- 컬러 이미지는 BGR 3채널로 구성됨. 히스토그램 처리를 위해 각 채널을 분리해야 함.
- ``` C++
  vector<Mat> BGR_planes;
  split(srcImage, BGR_planes); // BGR_planes[0] = Blue 채널, BGR_planes[1] = Green 채널, BGR_planes[2] = Red 채널
  ```

### 히스토그램
- 픽셀 값의 분포, 즉 밝기 값(0~255)이 이미지에 얼마나 분포되어 있는지를 나타내는 빈도수 통계 그래프
- x축: 밝기 값 (0~255)
- y축: 해당 밝기값을 가진 픽셀의 개수 (빈도 수)

- y축
- 그레이스케일 이미지: 픽셀 하나당 밝기값(0~255) → 1차원 히스토그램으로 충분
- 컬러 이미지(BGR): 픽셀 하나에 3가지 값(B, G, R) → 밝기 분포가 3채널로 나뉨
- R, G, B 각각의 밝기 분포가 다르기 때문에 컬러 이미지는 히스토그램도 3개 필요
- ``` C++
  calcHist(&BGR_planes[c], 1, nullptr, noArray(), hists[c], 1, &histSize, ranges, true, false);
  /*
  images	이미지 배열. 보통 &image 또는 &channels[i]
  nimages	이미지 개수 (보통 1개니까 1)
  channels	사용할 채널 번호 배열 (예: {0} → 0번 채널만 사용)
  mask	ROI (Region of Interest) 설정할 때 사용. 없으면 Mat() 또는 noArray()
  hist	결과를 저장할 Mat 객체
  dims	히스토그램의 차원 수 (1D, 2D 등)
  histSize	각 차원의 bin 개수 (예: {256} → 256개의 밝기값 bin)
  ranges	각 차원의 값 범위 (예: {0, 256} → 밝기 0~255)
  uniform	bin 크기가 일정한가? 대부분 true
  accumulate	이전 값에 누적할 것인가? 보통 false
  */
  ```
#### 이미지 및 히스토그램 출력 예제
``` C++
// 1. 원본 이미지를 읽어오기.
// 2. 흑백 이미지의 히스토그램을 계산하고 시각화.
// 3. 컬러 이미지의 각 채널 (R, G, B)별 히스토그램을 계산하고 시각화.
// 4. 원본 이미지와 그에 대응하는 히스토그램을 동시에 출력

#include <opencv2/opencv.hpp>
#include <iostream>
using namespace cv;
using namespace std;

int main() {
    // 공통으로 사용되는 변수들
    int histSize = 256; // 256개의 밝기 bin
    float range[] = { 0, 256 }; // 밝기 범위 0~255
    const float* ranges[] = { range }; // 히스토그램 범위
    int hist_w = 512, hist_h = 400; // 히스토그램 이미지 크기
    int bin_w = cvRound((double)hist_w / histSize); // bin 너비

    // 1. 이미지 불러오기
    Mat grayImage = imread("흑백.png", IMREAD_GRAYSCALE); // 흑백 이미지
    Mat colorImage = imread("컬럼.png"); // 컬러 이미지 (BGR)

    // 2. 흑백 이미지의 히스토그램 계산
    if (grayImage.empty()) {
        cerr << "Error: Could not load the grayscale image!" << endl;
        return -1;
    }

    // 히스토그램을 저장할 Mat 객체
    Mat grayHist;
    calcHist(&grayImage, 1, 0, Mat(), grayHist, 1, &histSize, ranges, true, false);

    // 3. 컬러 이미지의 히스토그램 계산
    if (colorImage.empty()) {
        cerr << "Error: Could not load the color image!" << endl;
        return -1;
    }

    // BGR 채널 분리
    vector<Mat> bgr_planes;
    split(colorImage, bgr_planes); // BGR 채널 분리

    // 각 채널의 히스토그램 계산
    Mat bHist, gHist, rHist;
    calcHist(&bgr_planes[0], 1, 0, Mat(), bHist, 1, &histSize, ranges, true, false); // Blue
    calcHist(&bgr_planes[1], 1, 0, Mat(), gHist, 1, &histSize, ranges, true, false); // Green
    calcHist(&bgr_planes[2], 1, 0, Mat(), rHist, 1, &histSize, ranges, true, false); // Red

    // 4. 히스토그램 시각화

    // 흑백 이미지 히스토그램을 위한 빈 이미지 생성
    Mat grayHistImage(hist_h, hist_w, CV_8UC1, Scalar(255)); // 흑백 히스토그램 이미지

    // 흑백 이미지 히스토그램 그리기
    normalize(grayHist, grayHist, 0, grayHistImage.rows, NORM_MINMAX, -1, Mat());
    for (int i = 1; i < histSize; i++) {
        line(grayHistImage, Point(bin_w * (i - 1), hist_h - cvRound(grayHist.at<float>(i - 1))),
                      Point(bin_w * i, hist_h - cvRound(grayHist.at<float>(i))),
                      Scalar(0), 2, 8, 0); // 흑백히스토그램은 검은색으로
    }

    // 컬러 이미지 히스토그램을 위한 빈 이미지 생성
    Mat colorHistImage(hist_h, hist_w, CV_8UC3, Scalar(255, 255, 255)); // 컬러 히스토그램 이미지

    // 각 채널의 히스토그램을 컬러로 그리기
    normalize(bHist, bHist, 0, colorHistImage.rows, NORM_MINMAX, -1, Mat());
    normalize(gHist, gHist, 0, colorHistImage.rows, NORM_MINMAX, -1, Mat());
    normalize(rHist, rHist, 0, colorHistImage.rows, NORM_MINMAX, -1, Mat());

    for (int i = 1; i < histSize; i++) {
        // Blue 채널 (파란색)
        line(colorHistImage, Point(bin_w * (i - 1), hist_h - cvRound(bHist.at<float>(i - 1))),
                          Point(bin_w * i, hist_h - cvRound(bHist.at<float>(i))),
                          Scalar(255, 0, 0), 2, 8, 0);

        // Green 채널 (초록색)
        line(colorHistImage, Point(bin_w * (i - 1), hist_h - cvRound(gHist.at<float>(i - 1))),
                          Point(bin_w * i, hist_h - cvRound(gHist.at<float>(i))),
                          Scalar(0, 255, 0), 2, 8, 0);

        // Red 채널 (빨간색)
        line(colorHistImage, Point(bin_w * (i - 1), hist_h - cvRound(rHist.at<float>(i - 1))),
                          Point(bin_w * i, hist_h - cvRound(rHist.at<float>(i))),
                          Scalar(0, 0, 255), 2, 8, 0);
    }

    // 5. 결과 출력
    imshow("Grayscale Image", grayImage); // 흑백 이미지
    imshow("Grayscale Histogram", grayHistImage); // 흑백 이미지 히스토그램

    imshow("Color Image", colorImage); // 컬러 이미지
    imshow("Color Histogram", colorHistImage); // 컬러 이미지 히스토그램

    waitKey(0); // 키를 누르면 종료
    destroyAllWindows(); // 모든 창 닫기

    return 0;
}


```

  
### 히스토그램 균일화(Equalization)

![image](https://github.com/user-attachments/assets/ea74cd5f-d19c-4744-8845-141169205eff)

1. 균일화
  - 원본 이미지의 명암 분포가 특정 구간에 몰려 있을 경우, 전체 범위(0~255)를 고르게 퍼지게 만들어 **대비(contrast)**를 향상시키는 기법.
  - 이미지의 히스토그램을 균일하게 분포시키는 기법
  - ``` c++
    Mat equalized;
    equalizeHist(grayImage, equalized);
    imshow("Equalized Image", equalized);
    ```
2. 이미지 및 히스토그램 변화
  - 원본 이미지
      - 명암이 중간 밝기 근처에 집중되어 있고, 대비가 낮음.
      - 히스토그램이 특정 밝기대에 몰려 있음.
  - 균등화 이미지
      - 전체 밝기 범위로 픽셀 값이 분산됨 → 대비가 높아져 디테일이 선명하게 보임.
      - 히스토그램이 전체적으로 퍼져 있음.

Q. ```normalize(hists[c], hists[c], 0, hist_h * max_count[c] / max_count_for_all, NORM_MINMAX, -1, noArray());``` 수식의 의미? 

``` 🧮 왜 이렇게 쓰는가?
예를 들어,
Red 채널 최대값: 9000
Green 채널 최대값: 4000
Blue 채널 최대값: 6000
이 중 전체 최대는 9000 → 이걸 기준으로 삼음

그러면
Red는 hist_h로 정규화됨 (400)
Green은 400 * 4000 / 9000 ≈ 178
Blue는 400 * 6000 / 9000 ≈ 267

즉, 다른 채널들도 같은 높이 범위 내에서 상대적으로 표시되도록 만드는 방식!
``` 

![image](https://github.com/user-attachments/assets/d1a2864d-54ec-4e78-9a77-eaa1a479c6ba)


## Image Thresholding

## Image Blending
