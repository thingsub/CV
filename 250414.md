# 250414
## Image Histogram
### Mat 클래스
- 이미지를 행렬 형태로 저장
- ``` C++
  Mat srcImage = imread("lena.jpg"); // srcImage는 Mat 객체이고, 이미지 파일을 불러와서 메모리에 저장함.
  ```
#### Q. cv::Mat 활용 이유?
- Mat은 단순히 이미지만 저장하는 클래스가 아님. 행렬 형태의 데이터라면 이미지든 필터 커널이든 히스토그램이든 모두 표현 가능
- calcHist() 같은 함수들이 히스토그램 출력을 Mat으로 반환

### 이미지 채널 분리(split)
- 컬러 이미지는 BGR 3채널로 구성됨. 히스토그램 처리를 위해 각 채널을 분리해야 함.
- ``` C++
  vector<Mat> BGR_planes;
  split(srcImage, BGR_planes); // BGR_planes[0] = Blue 채널, BGR_planes[1] = Green 채널, BGR_planes[2] = Red 채널
  ```

### 히스토그램
- 픽셀 값의 분포, 즉 밝기 값(0~255)이 이미지에 얼마나 분포되어 있는지를 나타내는 빈도수 통계 그래프
- x축: 밝기 값 (0~255)
- y축: 해당 밝기값을 가진 픽셀의 개수 (빈도 수)

- y축
- 그레이스케일 이미지: 픽셀 하나당 밝기값(0~255) → 1차원 히스토그램으로 충분
- 컬러 이미지(BGR): 픽셀 하나에 3가지 값(B, G, R) → 밝기 분포가 3채널로 나뉨
- R, G, B 각각의 밝기 분포가 다르기 때문에 컬러 이미지는 히스토그램도 3개 필요
- ``` C++
  calcHist(&BGR_planes[c], 1, nullptr, noArray(), hists[c], 1, &histSize, ranges, true, false);
  /*
  images	이미지 배열. 보통 &image 또는 &channels[i]
  nimages	이미지 개수 (보통 1개니까 1)
  channels	사용할 채널 번호 배열 (예: {0} → 0번 채널만 사용)
  mask	ROI (Region of Interest) 설정할 때 사용. 없으면 Mat() 또는 noArray()
  hist	결과를 저장할 Mat 객체
  dims	히스토그램의 차원 수 (1D, 2D 등)
  histSize	각 차원의 bin 개수 (예: {256} → 256개의 밝기값 bin)
  ranges	각 차원의 값 범위 (예: {0, 256} → 밝기 0~255)
  uniform	bin 크기가 일정한가? 대부분 true
  accumulate	이전 값에 누적할 것인가? 보통 false
  */
  ```
#### 이미지 및 히스토그램 출력 예제
``` C++
// 1. 원본 이미지를 읽어오기.
// 2. 흑백 이미지의 히스토그램을 계산하고 시각화.
// 3. 컬러 이미지의 각 채널 (R, G, B)별 히스토그램을 계산하고 시각화.
// 4. 원본 이미지와 그에 대응하는 히스토그램을 동시에 출력

#include <opencv2/opencv.hpp>
#include <iostream>
using namespace cv;
using namespace std;

int main() {
    // 공통으로 사용되는 변수들
    int histSize = 256; // 256개의 밝기 bin
    float range[] = { 0, 256 }; // 밝기 범위 0~255
    const float* ranges[] = { range }; // 히스토그램 범위
    int hist_w = 512, hist_h = 400; // 히스토그램 이미지 크기
    int bin_w = cvRound((double)hist_w / histSize); // bin 너비

    // 1. 이미지 불러오기
    Mat grayImage = imread("흑백.png", IMREAD_GRAYSCALE); // 흑백 이미지
    Mat colorImage = imread("컬럼.png"); // 컬러 이미지 (BGR)

    // 2. 흑백 이미지의 히스토그램 계산
    if (grayImage.empty()) {
        cerr << "Error: Could not load the grayscale image!" << endl;
        return -1;
    }

    // 히스토그램을 저장할 Mat 객체
    Mat grayHist;
    calcHist(&grayImage, 1, 0, Mat(), grayHist, 1, &histSize, ranges, true, false);

    // 3. 컬러 이미지의 히스토그램 계산
    if (colorImage.empty()) {
        cerr << "Error: Could not load the color image!" << endl;
        return -1;
    }

    // BGR 채널 분리
    vector<Mat> bgr_planes;
    split(colorImage, bgr_planes); // BGR 채널 분리

    // 각 채널의 히스토그램 계산
    Mat bHist, gHist, rHist;
    calcHist(&bgr_planes[0], 1, 0, Mat(), bHist, 1, &histSize, ranges, true, false); // Blue
    calcHist(&bgr_planes[1], 1, 0, Mat(), gHist, 1, &histSize, ranges, true, false); // Green
    calcHist(&bgr_planes[2], 1, 0, Mat(), rHist, 1, &histSize, ranges, true, false); // Red

    // 4. 히스토그램 시각화

    // 흑백 이미지 히스토그램을 위한 빈 이미지 생성
    Mat grayHistImage(hist_h, hist_w, CV_8UC1, Scalar(255)); // 흑백 히스토그램 이미지

    // 흑백 이미지 히스토그램 그리기
    normalize(grayHist, grayHist, 0, grayHistImage.rows, NORM_MINMAX, -1, Mat());
    for (int i = 1; i < histSize; i++) {
        line(grayHistImage, Point(bin_w * (i - 1), hist_h - cvRound(grayHist.at<float>(i - 1))),
                      Point(bin_w * i, hist_h - cvRound(grayHist.at<float>(i))),
                      Scalar(0), 2, 8, 0); // 흑백히스토그램은 검은색으로
    }

    // 컬러 이미지 히스토그램을 위한 빈 이미지 생성
    Mat colorHistImage(hist_h, hist_w, CV_8UC3, Scalar(255, 255, 255)); // 컬러 히스토그램 이미지

    // 각 채널의 히스토그램을 컬러로 그리기
    normalize(bHist, bHist, 0, colorHistImage.rows, NORM_MINMAX, -1, Mat());
    normalize(gHist, gHist, 0, colorHistImage.rows, NORM_MINMAX, -1, Mat());
    normalize(rHist, rHist, 0, colorHistImage.rows, NORM_MINMAX, -1, Mat());

    for (int i = 1; i < histSize; i++) {
        // Blue 채널 (파란색)
        line(colorHistImage, Point(bin_w * (i - 1), hist_h - cvRound(bHist.at<float>(i - 1))),
                          Point(bin_w * i, hist_h - cvRound(bHist.at<float>(i))),
                          Scalar(255, 0, 0), 2, 8, 0);

        // Green 채널 (초록색)
        line(colorHistImage, Point(bin_w * (i - 1), hist_h - cvRound(gHist.at<float>(i - 1))),
                          Point(bin_w * i, hist_h - cvRound(gHist.at<float>(i))),
                          Scalar(0, 255, 0), 2, 8, 0);

        // Red 채널 (빨간색)
        line(colorHistImage, Point(bin_w * (i - 1), hist_h - cvRound(rHist.at<float>(i - 1))),
                          Point(bin_w * i, hist_h - cvRound(rHist.at<float>(i))),
                          Scalar(0, 0, 255), 2, 8, 0);
    }

    // 5. 결과 출력
    imshow("Grayscale Image", grayImage); // 흑백 이미지
    imshow("Grayscale Histogram", grayHistImage); // 흑백 이미지 히스토그램

    imshow("Color Image", colorImage); // 컬러 이미지
    imshow("Color Histogram", colorHistImage); // 컬러 이미지 히스토그램

    waitKey(0); // 키를 누르면 종료
    destroyAllWindows(); // 모든 창 닫기

    return 0;
}


```

  
### 히스토그램 균일화(Equalization)

![image](https://github.com/user-attachments/assets/ea74cd5f-d19c-4744-8845-141169205eff)

1. 균일화
  - 원본 이미지의 명암 분포가 특정 구간에 몰려 있을 경우, 전체 범위(0~255)를 고르게 퍼지게 만들어 **대비(contrast)**를 향상시키는 기법.
  - 이미지의 히스토그램을 균일하게 분포시키는 기법
  - ``` c++
    Mat equalized;
    equalizeHist(grayImage, equalized);
    imshow("Equalized Image", equalized);
    ```
2. 이미지 및 히스토그램 변화
  - 원본 이미지
      - 명암이 중간 밝기 근처에 집중되어 있고, 대비가 낮음.
      - 히스토그램이 특정 밝기대에 몰려 있음.
  - 균등화 이미지
      - 전체 밝기 범위로 픽셀 값이 분산됨 → 대비가 높아져 디테일이 선명하게 보임.
      - 히스토그램이 전체적으로 퍼져 있음.

Q. ```normalize(hists[c], hists[c], 0, hist_h * max_count[c] / max_count_for_all, NORM_MINMAX, -1, noArray());``` 수식의 의미? 

``` 🧮 왜 이렇게 쓰는가?
예를 들어,
Red 채널 최대값: 9000
Green 채널 최대값: 4000
Blue 채널 최대값: 6000
이 중 전체 최대는 9000 → 이걸 기준으로 삼음

그러면
Red는 hist_h로 정규화됨 (400)
Green은 400 * 4000 / 9000 ≈ 178
Blue는 400 * 6000 / 9000 ≈ 267

즉, 다른 채널들도 같은 높이 범위 내에서 상대적으로 표시되도록 만드는 방식!
``` 

![image](https://github.com/user-attachments/assets/d1a2864d-54ec-4e78-9a77-eaa1a479c6ba)


## Image Thresholding

## Image Blending

## second 과제

#### 함수 정리
- imread 함수:
  - OpenCV의 imread() 함수는 파일에서 이미지를 읽어 Mat 객체에 저장하는 함수.
  - Mat은 이미지 데이터를 저장하는 OpenCV의 기본 자료형으로, 행렬(matrix) 형식으로 이미지를 처리합니다.
- imshow 함수:
    - 이미지를 창으로 표시하는 함수.
    - 현 코드에서 여러 개의 창을 띄워서 로고, 채널별 이진화 결과, 비트 연산 결과를 출력
- cvtColor 함수 :
    - 이미지를 색상 공간을 변환하는 함수
    - ``` C++
      cvtColor(img_logo, img_logo_gray, COLOR_BGR2GRAY);
      // COLOR_BGR2GRAY: BGR(Blue, Green, Red) 컬러 이미지를 그레이스케일로 변환하는 코드
      ```
- threshold 함수 :
  - 이미지를 이진화하는 함수
  - 이미지의 각 픽셀을 특정 값과 비교하여 초과하는 부분은 255(흰색)로, 나머지는 0(검은색)으로 설정
  - ``` C++
    // 각 채널에 이진화 적용
    threshold(bgr_channels[0], thresh_b, 100, 255, THRESH_BINARY);
    threshold(bgr_channels[1], thresh_g, 100, 255, THRESH_BINARY);
    threshold(bgr_channels[2], thresh_r, 100, 255, THRESH_BINARY);
  - ㅇㅇ
- bitwise_not 함수
  - 비트 연산의 "NOT" 연산을 수행하여, 마스크를 반전시키는 함수
  -  ㅇㅇ
- destroyAllWindows 함수
  - 모든 OpenCV 윈도우를 닫는 함수

#### ROI(Region Of Interest)

  1. ROI 설정
  - 이미지에서 우리가 관심 있는 특정 영역
  - ex) 전체 이미지에서 얼굴만 처리하고 싶다면, 얼굴이 있는 부분(영역)만 선택하여 그 부분에 대해 연산을 수행
  ```C++
  Mat img_messi = imread("messi5.jpg");  // 전체 이미지
  Mat img_logo = imread("opencv-logo-white.png");  // 로고 이미지
  Mat img_roi = img_messi(Rect(0, 0, img_logo.cols, img_logo.rows));  // 왼쪽 상단 (0, 0)에서 로고 크기만큼 선택
  // 참고로 Rect(0, 0, img_logo.cols, img_logo.rows)는 ROI를 지정하는 코드
  // Rect는 사각형을 나타내며, (0, 0)은 좌상단 (x, y) 위치를 의미하고, img_logo.cols와 img_logo.rows는 너비와 높이를 의미
  // 즉, 이 코드는 img_logo의 크기만큼, img_messi 이미지에서 왼쪽 상단 부분을 잘라내겠다는 뜻
  ```
    
  2. 구체적인 동작
     - ROI를 설정하는 방식은 이미지에서 특정 영역을 잘라내는 것.
     - 보통 사각형 영역을 선택하며, 이를 Rect 객체로 정의
