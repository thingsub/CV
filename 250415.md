### 개념 정리

### Kernal
- (보통 N by N 크기의) 작은 정사각형
- 이미지 위를 슬라이딩하며 위치별 주변 픽셀들과 연산 수행
- ``` C++
      // 커널을 ones()로 정의: 3x3 크기, 모든 값이 1인 행렬 생성
      // 일일이 수동 입력해서 생성할 수도 있음.
      Mat kernel = Mat::ones(3, 3, CV_32F);  // 3x3 크기의 float형 행렬로 모두 1로 채워짐
  ```
    - ``` Mat::ones() ``` : 행렬의 모든 원소를 1로 채운다.
    - ``` Mat::zeros() ```: 행렬의 모든 원소를 0으로 채운다.

### Filter
- Kernal을 실제로 적용하는 방식
### Filter 종류(OpenCV 제공 함수)
#### 1. blur(): 
평균값을 사용하는 간단한 박스 필터
#### 1. GaussianBlur(): 
가우시안 분포를 따르는 가우시안 필터
#### 1. medianBlur(): 
각 픽셀 주변 값의 중앙값을 사용하는 미디안 필터
#### 1. bilateralFilter(): 
엣지를 보존하면서 노이즈를 제거하는 양방향 필터
  
  ``` c++
   #include <opencv2/opencv.hpp>
  #include <iostream>
  using namespace cv;
  using namespace std;
  
  int main() {
      // 1. 이미지 로드
      Mat srcImage = imread("lena.jpg");  // 이미지 경로를 정확히 지정하세요.
      if (srcImage.empty()) {
          cerr << "Error: Could not load the image!" << endl;
          return -1;
      }

    // 2. 결과를 저장할 Mat 객체들
    Mat boxFiltered, gaussianFiltered, medianFiltered, bilateralFiltered;

    // 3. Box Filter 적용 (평균 필터)
    blur(srcImage, boxFiltered, Size(5, 5)); // 5x5 Box Filter

    // 4. Gaussian Filter 적용
    GaussianBlur(srcImage, gaussianFiltered, Size(5, 5), 0); // 5x5 Gaussian Filter

    // 5. Median Filter 적용
    medianBlur(srcImage, medianFiltered, 5); // 5x5 Median Filter

    // 6. Bilateral Filter 적용
    bilateralFilter(srcImage, bilateralFiltered, 9, 75, 75); // 필터 크기 및 파라미터

    // 7. 각 필터링된 이미지 출력
    imshow("Original Image", srcImage); // 원본 이미지
    imshow("Box Filtered Image", boxFiltered); // Box Filter 이미지
    imshow("Gaussian Filtered Image", gaussianFiltered); // Gaussian Filter 이미지
    imshow("Median Filtered Image", medianFiltered); // Median Filter 이미지
    imshow("Bilateral Filtered Image", bilateralFiltered); // Bilateral Filter 이미지

    // 8. 키 입력 대기 후 모든 창 닫기
    waitKey(0); 
    destroyAllWindows();

    return 0;
  }

  ```

### 필터링 흐름(2가지 : A -> C 또는 B -> C)

#### A-1. 커널 정의: 
필터링에 사용될 커널을 정의. 커널은 필터링 연산을 위한 핵심 요소
``` C++
Mat kernel = Mat::ones(3, 3, CV_32F) / 9.0f;  // 3x3 박스 필터
```
#### A-2. 필터 선택 및 적용: 
- 어떤 종류의 필터를 사용할지 결정. 각 필터는 서로 다른 효과를 생성 (예: 흐림, 노이즈 제거 등)
- 커널을 이미지에 적용하여 필터링 수행. 이때 커널은 이미지에서 슬라이딩되며 각 픽셀에 대해 연산이 수행됨.
``` C++
Mat dstImage;  // 필터링된 결과를 저장할 변수
filter2D(srcImage, dstImage, -1, kernel);  // 커널을 사용해 필터링 적용
```

#### B-1. 특정 필터 함수 적용
``` C++
GaussianBlur(srcImage, dstImage, Size(5, 5), 0);  // 5x5 가우시안 필터 적용
```
#### C-1. 결과 확인: 
필터링 후 결과 이미지를 확인하여 효과를 검토
``` C++
imshow("Original Image", srcImage);     // 원본 이미지
imshow("Filtered Image", dstImage);     // 필터링된 이미지
waitKey(0);  // 키를 누르면 창 닫기
destroyAllWindows();  // 모든 창 닫기

```
![image](https://github.com/user-attachments/assets/02a4256e-f571-42e9-9dc8-fe114c7aad1a)

### 고주파 vs 저주파

![image](https://github.com/user-attachments/assets/2e9b22d5-1dc1-454a-a28e-4a09d653cdbb)

- 고주파 (High Frequency):
  - 고주파는 빠르고 급격한 변화, 세밀한 디테일을 나타낸다. 
  - ex) 이미지의 엣지, 모서리, 잡음 등

- 저주파 (Low Frequency):
  - 저주파는 점진적이고 부드러운 변화, 넓은 범위 혹은 전체적인 형태를 나타낸다. 
  - ex) 이미지의 배경, 그라데이션, 부드러운 영역 등

- Low-pass filter = 저주파는 지나가고, 고주파는 막는다
- High-pass filter = 고주파는 지나가고, 저주파는 막는다<br>
(거른다는 의미의 filter보다는, 통과시킨다는 의미의 pass에 더 중점을 두어 혼란에 빠지지 말자.)

Corr vs Conv (tmi. 요즘 코컨 사람 많다)
커널을 통해 필터링할 때, 그 연산은 Corr 또는 Conv 



cf. https://overface.tistory.com/601
